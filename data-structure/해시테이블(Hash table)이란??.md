---
title: "해시테이블(hash table)이란??"
date: 2022-05-24
categories: [자료구조]
---
## 해시테이블이란??

hash table은 key를 value에 매핑할 수 있는 자료구조로서 효율적인 탐색(빠른 탐색)을 할수 있게 해준다. 해시함수에 key값을 입력으로 넣어 얻은 해시값을 인덱싱하여 저장한다.

> **해시 함수란??**

임의 크기 데이터를 고정 크기 값으로 매핑하는 데 사용할 수 있는 함수를 말하며 `MD4`, `MD5`, `SHA`등이 있다. 다양한 해싱 알고리즘이 있지만 가장 단순하면서도 널리 쓰이는 알고리즘으로는 정수형 해싱 기법인 모듈러 연산을 이용한 나눗셈 방식이 있다.

수식은 다음과 같이 정리할 수 있다.  
`h(x)= x mod m`  
여기서 h(x)는 입력값 x의 해시 함수를 통해 생성된 결과로 m은 해시 테이블의 크기이며 일반적으로 소수를 선택하는 것이 좋다.

해시 함수 알고리즘은 이정도로 하고 넘어가면 좋을듯하다.  
(수많은 해시 알고리즘이 있기에 이 블로그에 전부 정리하는것은 너무 비효율적이다.)

한가지만 짚고 넘어가면 되는데,  
그렇다면 모든 데이터를 해시 할 수 있느냐??  
그것은 아니다!

해시할 수 있는 데이터를 일명 hashable (해싱가능) 이라고 하는데,  
이는 데이터의 불변성, 불변객체와 관련이 있다.

-   불변 객체란? : 인스턴스가 메모리를 할당받아 한 번 생성되고 나면 변하지 않는것을 말한다.

해시가능함과 불병성이 왜 서로 연관이 있냐하면, 해시 알고리즘으로부터 얻은 해시 키는 불변으로 변하지 않아야 하기 때문이다. 만약 해시 키가 불변이 아니고 변할 수 있다면 해시 테이블 같은 자료구조 내에서 객체가 저장된 위치 또한 변하게 되는것을 의미하기 때문이다.

하여, python의 hashtable 인 딕셔너리는 키 값으로 리스트와 딕셔너리, 세트 등을 사용할 수 없는것이다.

> **Direct-address table을 먼저 짚고 넘어가자면**

direct-address table(직접 주소화 테이블)이란, 키값으로 k를 갖는 원소는 인덱스 k에 저장하는 방식을 말한다.

```
key: 출석번호, value: 이름
(3, 노정호)
(5, 배준석)
(6, 정재헌)
(7, 남영욱)
이와 같은 키, 값이 있을때
```

![](https://velog.velcdn.com/images/lkdfj6/post/716a43ed-88cc-431e-8565-0e2494271e41/image.png)

직접 주소화 방법을 통해 데이터를 저장하고자 하면 많은 문제가 발생한다.

-   불필요한 공간낭비

```
key: 학번, value: 이름
(2022390, 노정호)
(2022392, 배준석)
(2022393, 정재헌)
(2022401, 남영욱)
```

![](https://velog.velcdn.com/images/lkdfj6/post/54bf11ed-cccf-45ec-9bd3-08acbf94cd69/image.png)

-   key가 다양한 자료형을 담을 수 없게 됨

```
key: ID, value: 이름
(nossi8128, 노정호)
(js9876, 배준석)
(amad22, 정재헌)
(uk232, 남영욱)
```

![](https://velog.velcdn.com/images/lkdfj6/post/6fdf0c05-c31c-497d-a1dd-927296e89f38/image.png)

> **이런 단점들을 보완한 자료구조 -> Hash table**

(key, value) 데이터 쌍을 저장하기 위한 방법으로 직접 주소화 방법은 잘 맞지 않는것을 위의 예시를 통해 알게되었다. 이런 단점을 보완하여 나온 자료구조가 해시테이블이다.  
해시테이블은 해시함수 h를 이용해서 (key, value)를 인덱스에 저장한다.  
해시테이블을 구성하고 있는 각각의 공간을 slot 또는 bucket이라고 명칭한다.

![](https://velog.velcdn.com/images/lkdfj6/post/73177658-b740-4181-a7e9-5c5bf2fae3e6/image.png)

![](https://velog.velcdn.com/images/lkdfj6/post/95c53a6f-973b-4d28-8058-cde7ffff8c96/image.png)  
하여 위와 같이 키값으로 들어오는 정수가 매우 큰 수이거나, 아예 정수가 아닌 문자형일때에도 해시함수를 거치면 인덱싱이 가능하다.

> **시간복잡도와 공간효율**

**시간복잡도:** 저장, 삭제, 검색 모두 기본적으로 O(1)이지만, collision으로 인하여 최악의 경우 O(n)이 될 수 있다.

**공간효율성:** 데이터가 저장되기 전에 미리 저장공간(slot, bucket)을 확보해야 하기 때문에 공간효율성은 떨어진다.

> **해시 테이블의 단점 collision 이란??**

collision이란 서로 다른 key의 해시값이 똑같을 때를 말한다. 즉, 중복되는 key는 없지만 해시값은 중복될 수 있는데 이 때 collision이 발생했다고 한다.

> **collision이 발생 하면 어떻게 해결하는가?**

**1\. open addressing 방식:** collision이 발생하면 미리 정한 규칙에 따라 hash table의 비어있는 slot을 찾아서 저장한다. 빈 slot을 찾는 방법에 따라 Linear probing, Quadratic probing, Double hashing 으로 나뉜다.

-   **Linear probing(선형 탐사법):** 충돌이 발생한 해시값으로 부터 일정한 값만큼(+1, +2, +3,...)건너 뛰어, 비어있는 slot에 데이터를 저장한다.
    
-   **Quadratic probing(제곱 탐사법):** 충돌이 발생한 해시값으로 부터 일정한 값만큼(+1^2, +2^2, +3^2,...)건너 뛰어, 비어있는 slot에 데이터를 저장한다.
    

선형 탐사 및 제곱 탐사는 충돌 횟수가 많아지면 특정 영역에 데이터가 집중적으로 몰리는 클러스터링(clustring)현상이 발생하는 단점이 있다. 클러스터링 현상이 발생하면, 평균 탐색 시간이 증가하게 된다.

-   **Doble hashing(이중 해싱):** 선형 탐사법이나 제곱 탐사법은 탐사 이동폭이 같기 때문에 클러스터링 문제가 발생할 수 있다. 이 문제를 발생하지 않도록 처음부터 2개의 해시 함수를 사용하는 방식을 이중 해싱이라고 하는데, 하나는 최초의 해시값을 얻을 때 사용하고 또 다른 하나는 해시 충돌이 발생할 때 탐사 이동폭을 얻기 위해 사용한다.

**또한, 오픈 어드레싱 방식은** 키의 개수가 버킷의 사이즈 보다 큰 경우에는 삽입할 수 없다. 그래서 일정 이상 데이터들로 채워지면, 즉 기준이 되는 로드팩터 비율을 넘어서게 되면 그로스 팩터의 비율에 따라 더 큰 크기의 또 다른 버킷을 생성한 후 여기에 새롭게 복사하는 리해싱 작업이 일어나다. 이는 동적 배열에서 공간이 가득 찰 경우 더블링으로 새롭게 복사해서 옮겨가는 과정과 유사하다.

`로드 팩터란??`  
**load factor = n/k** 으로,  
해시 테이블에 저장된 데이터의 개수 n을, 버킷의 개수 k로 나눈것을 말한다.

이 로드팩터의 비율에 따라서 해시 함수를 재작성해야 될지 또는 해시 테이블의 크기를 조정해야 할 지를 결정한다. 자바10에서는 해시맵의 디폴트 로드 팩터를 0.75이고 파이썬의 경우 0.66으로 설정하며 이 값을 넘어서게 될 경우 동적 배열처럼 해시 테이블의 공간을 재할당한다.

**2\. separate chaining 방식:** collision이 발생하면 linked list에 slot을 추가하여 데이터를 저장한다.

![](https://velog.velcdn.com/images/lkdfj6/post/f5843c05-ae87-422e-9a0a-d516e2e886b0/image.png)

-   삽입: 서로 다른 두 key가 같은 해시값을 갖게 되면 linked list에 node를 추가하여 데이터 쌍을 저장한다. 삽입의 시간복잡도는 O(1)이다.
    
-   검색: 기본적으로 O(1)의 시간복잡도 이지만 최악의 경우 O(n)의 시간복잡도를 갖는다.
    
-   삭제: 삭제 하기 위해선 검색을 먼저 해야하므로 검색의 시간복잡도와 동일하다. 기본적으로 O(1)이지만 최악의 경우 O(n)의 시간복잡도를 갖는다.
    

`최악의 경우 n개의 모든 key가 동일한 해시값을 갖게 되면 길이 n의 linked list가 생성되게 된다. 따라서 이때 검색의 시간복잡도가 O(n)이 된다.`